"""Channel transformations."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_transforms.ipynb.

# %% auto 0
__all__ = ['Transform', 'ParDo', 'as_transform', 'SeqDo', 'CancelPrev', 'Event', 'Streamable', 'use_sink', 'cur_sink', 'tfn']

# %% ../nbs/02_transforms.ipynb 3
import abc
import asyncio
import time
import uuid
import inspect
import contextlib
import contextvars
import dataclasses
from typing import Any, Callable, ParamSpec, Protocol, Generic, TypeVar, Awaitable
import functools

from fastcore.basics import patch

import fastagent_hacking.streams as sx
import fastagent_hacking.channels as cx

# %% ../nbs/02_transforms.ipynb 7
_I = TypeVar("I")
_O = TypeVar("O")


class Transform(abc.ABC, Generic[_I, _O]):

    @abc.abstractmethod
    def __call__(self, chan: cx.Channel[_I]) -> cx.Channel[_O]:
        """Transforms the input channel into an output channel."""

# %% ../nbs/02_transforms.ipynb 8
# FIXME: Move this to a separate module.
def _print_task_errors(task: asyncio.Task):
    if task.exception():
        task.print_stack()
        print(f"Task failed with exception: {task.exception()}")

# %% ../nbs/02_transforms.ipynb 10
import collections


class ParDo(Transform[_I, _O]):
    """Processes each element in the input channel using a user-defined function."""

    def __init__(self, fn):  # FIXME: type hint
        self._fn = fn

        # Maintains a mapping from a packet.tag to a list of stream cancellation functions.
        # When a cancellation packet is received, all tasks associated with the tag
        # should be cancelled.
        # FIXME: Terminated tasks are currently not removed from the map.
        self._cncls_map = collections.defaultdict(list[Callable])

        self._bg_tasks = set()

    def __call__(self, chan: cx.Channel[_I]) -> cx.Channel[_O]:
        main_stream = sx.InMemStreamWriter()
        side_stream = sx.InMemStreamWriter()

        async def proc(chan):
            try:
                async for p in chan:
                    assert isinstance(p, cx.Packet)
                    if self._is_passthrough(p):
                        await side_stream.put(p)
                        if p.packet_type == cx.PacketType.CANCELLATION_PACKET:
                            # Cancel all tasks associated with the tag.
                            cncl_tag = p.payload
                            for cncl in self._cncls_map[cncl_tag]:
                                cncl()
                            del self._cncls_map[p.payload]
                        continue

                    s = self._proc_packet(p)
                    await main_stream.put(s)
            finally:
                await main_stream.shutdown()
                await side_stream.shutdown()

        t = asyncio.create_task(proc(chan))
        self._bg_tasks.add(t)
        t.add_done_callback(_print_task_errors)
        t.add_done_callback(self._bg_tasks.discard)

        return cx.as_chan(
            sx.interleave(
                side_stream.readonly(),
                sx.flatten(main_stream.readonly()),
            )
        )

    def _proc_packet(self, p: cx.Packet[_I]) -> sx.Stream[cx.Packet[_O]]:
        assert p.packet_type == cx.PacketType.DATA
        s, cncl = sx.streamify(self._fn, return_shutdown_fn=True)(p.payload)
        for tag in p.tags:
            self._cncls_map[tag].append(cncl)
        return sx.map(
            lambda x: cx.Packet(
                payload=x,
                packet_type=cx.PacketType.DATA,
                parent_packet_id=p.packet_id,
                tags=p.tags,
            ),
            s,
        )

    def _is_passthrough(self, p: cx.Packet) -> bool:
        return p.packet_type != cx.PacketType.DATA

# %% ../nbs/02_transforms.ipynb 11
def as_transform(fn: Callable | Transform) -> Transform:
    """Converts a function of a single argument into a Transform object."""
    if isinstance(fn, Transform):
        return fn

    return ParDo(fn)

# %% ../nbs/02_transforms.ipynb 12
@patch
def __or__(
    self: Transform,
    other,
) -> Transform:
    t1, t2 = self, as_transform(other)

    class ComposedTransform(Transform):

        def __call__(self, chan: cx.Channel) -> cx.Channel:
            return t2(t1(chan))

    return ComposedTransform()


@patch
def __ror__(
    self: Transform,
    other,
) -> Transform:
    t2, t1 = self, as_transform(other)

    class ComposedTransform(Transform):

        def __call__(self, chan: cx.Channel) -> cx.Channel:
            return t2(t1(chan))

    return ComposedTransform()

# %% ../nbs/02_transforms.ipynb 24
class SeqDo(Transform[_I, _O]):
    """Processes each element in the input channel using a user-defined function."""

    def __init__(self, fn):  # FIXME: type hint
        assert inspect.isasyncgenfunction(fn) or asyncio.iscoroutinefunction(
            fn
        ), f"Expected an async function, got {fn}"
        self._fn = fn

    def __call__(self, chan: cx.Channel[_I]) -> cx.Channel[_O]:
        writer = sx.InMemStreamWriter()

        async def proc(chan):
            try:
                async for p in chan:
                    assert isinstance(p, cx.Packet)
                    if self._is_passthrough(p):
                        await writer.put(p)
                        continue
                    fn = sx.streamify(self._fn)
                    # FIXME: This loop blocks side packets from being processed.
                    async for e in fn(p.payload):
                        await writer.put(
                            cx.Packet(
                                payload=e,
                                packet_type=cx.PacketType.DATA,
                                parent_packet_id=p.packet_id,
                                tags=p.tags,
                            ),
                        )
            finally:
                await writer.shutdown()

        asyncio.create_task(proc(chan)).add_done_callback(_print_task_errors)

        return cx.as_chan(writer.readonly())

    def _is_passthrough(self, p: cx.Packet) -> bool:
        return p.packet_type != cx.PacketType.DATA

# %% ../nbs/02_transforms.ipynb 29
class CancelPrev(Transform[_I, _O]):
    """Cancels previous packets and their derivatives when a new packet arrives.

    This is useful when you want to ensure that only the latest packet is processed.
    For example to avoid double texting in a chat application: When I user sends a new message,
    while the previous message is still being processed, we may want to cancel the processing of
    the previous message.
    """

    def __call__(self, chan: cx.Channel[_I]) -> cx.Channel[_O]:
        writer = sx.InMemStreamWriter()

        async def proc(chan):
            abort_tag = ""
            try:
                async for p in chan:
                    assert isinstance(p, cx.Packet)

                    # We broadcast a cancellation packet that targtets the previous
                    # packet and its derivatives.
                    if abort_tag:
                        await writer.put(cx.mk_cancellation_packet(tag=abort_tag))

                    # Compute a new abort tag for the next packet.
                    abort_tag = f"latch-{str(uuid.uuid4())}"
                    await writer.put(
                        cx.Packet(
                            payload=p.payload,
                            packet_type=cx.PacketType.DATA,
                            parent_packet_id=p.packet_id,
                            tags=(*p.tags, abort_tag),
                        ),
                    )
            finally:
                await writer.shutdown()

        asyncio.create_task(proc(chan)).add_done_callback(_print_task_errors)

        return cx.as_chan(writer.readonly())

# %% ../nbs/02_transforms.ipynb 33
@dataclasses.dataclass(frozen=True)
class Event:
    payload: Any
    src: str = ""

# %% ../nbs/02_transforms.ipynb 34
_R = TypeVar("_R")
_P = ParamSpec("_P")


class Streamable(Protocol[_P, _R]):

    def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R: ...

    def stream(self, *args: _P.args, **kwargs: _P.kwargs) -> cx.Channel[Event]: ...

    def __or__(self, other) -> Transform: ...

# %% ../nbs/02_transforms.ipynb 35
_sink_ctxvar = contextvars.ContextVar("_sink_contextvar", default=None)


@contextlib.contextmanager
def use_sink(sink: sx.StreamWriter):
    try:
        tok = _sink_ctxvar.set(sink)
        yield sink
    finally:
        _sink_ctxvar.reset(tok)


def cur_sink() -> sx.StreamWriter | None:
    return _sink_ctxvar.get()

# %% ../nbs/02_transforms.ipynb 36
# FIXME How to improve the type hinting for decorated @tfn functions? (e.g., keep their signature).


def tfn(fn: Callable[..., Awaitable[_R]]) -> Streamable:
    assert asyncio.iscoroutinefunction(fn) or inspect.isasyncgenfunction(
        fn
    ), "tfn can only be used with async functions or async generators"

    class _S(Streamable):

        def __init__(self):
            self._instance = None

        def __get__(self, instance, owner):
            """Ensure correct binding for instance methods."""
            if instance:
                self._instance = instance
            return self

        # TODO: Factor out the common code between __call__s.
        if inspect.isasyncgenfunction(fn):

            @functools.wraps(fn)
            async def __call__(self, *args, **kwargs):
                """Handles async generators"""
                sink = kwargs.pop("sink", None)
                if not sink:
                    sink = cur_sink()

                if "sink" in inspect.signature(fn).parameters:
                    kwargs["sink"] = sink

                if self._instance:
                    # This required for decorated instance methods.
                    args = (self._instance, *args)

                async for e in fn(*args, **kwargs):
                    yield e  # Async generator case

        else:

            @functools.wraps(fn)
            async def __call__(self, *args, **kwargs):
                """Handles normal async functions"""
                sink = kwargs.pop("sink", None)
                if not sink:
                    sink = cur_sink()

                if "sink" in inspect.signature(fn).parameters:
                    kwargs["sink"] = sink

                if self._instance:
                    # This required for decorated instance methods.
                    args = (self._instance, *args)

                return await fn(*args, **kwargs)  # Normal async function case

        def stream(self, *args, return_value: bool = False, **kwargs):
            """Returns a streamable version of the function."""
            sink = sx.InMemStreamWriter()
            with use_sink(sink):

                async def target():
                    nonlocal sink
                    try:
                        result = await self(
                            *args, **kwargs, sink=sink
                        )  # FIXME Should we overwrite chan if already passed?
                        if return_value:
                            await sink.put(result)
                    finally:
                        await sink.shutdown()

                # TODO: We probably need a task cleanup.
                asyncio.create_task(target()).add_done_callback(_print_task_errors)
                return sink.readonly()

        def __or__(self, other) -> Transform:
            t1, t2 = as_transform(self), as_transform(other)
            return t1 | t2

        def __ror__(self, other) -> Transform:
            t2, t1 = as_transform(self), as_transform(other)
            return t1 | t2

    wrapped = _S()
    if asyncio.iscoroutinefunction(fn):
        inspect.markcoroutinefunction(wrapped)

    return wrapped
